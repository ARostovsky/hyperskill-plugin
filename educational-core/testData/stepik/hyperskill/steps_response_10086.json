{
  "meta": {
    "page": 1,
    "has_next": false,
    "has_previous": false
  },
  "steps": [
    {
      "block": {
        "name": "text",
        "text": "<p>Generics were introduced to implement generic programming concept and control type-safety at compile-time. The feature has been available since Java 5. To support backward compatibility with previous Java versions, information about types is erased by the compiler.</p>\n\n<p>This means that at runtime all these objects will have the same type:</p>\n\n<pre><code class=\"language-java\">// Generic types\nList&lt;Integer&gt; integers = new List&lt;&gt;();\nList&lt;String&gt; strings = new List&lt;&gt;();\n\n// Raw type\nList objects = new List();</code></pre>\n\n<p>The transformation process is called <strong>type erasure</strong>. Let's take a closer look at what it actually does.</p>\n\n<h2>Generics replacement</h2>\n\n<p>First of all, type erasure replaces parameters of generic types with their left bound. In the case of unbounded ones, they are replaced by <code class=\"language-java\">Object</code> type. It means that information about types is erased when a program is translated into byte code. As a result, byte code contains only ordinary non-generic classes and interfaces.</p>\n\n<p>Let's consider the generic class <code class=\"language-java\">Data</code>:</p>\n\n<pre><code class=\"language-java\">class Data&lt;T&gt; {\n    private T data;\n\n    public T get() {\n        return data;\n    }\n\n    public void set(T data) {\n        this.data = data;\n    }\n}\n</code></pre>\n\n<p>Java compiler will replace the parameter <code class=\"language-java\">T</code> by <code class=\"language-java\">Object</code>, because <code class=\"language-java\"><tt>T</tt></code> is unbounded. Below is a code that is effectively the same as <code class=\"language-java\">Data&lt;T&gt;</code> after compilation:</p>\n\n<pre><code class=\"language-java\">class Data {\n    private Object data;\n\n    public Object get() {\n        return data;\n    }\n\n    public void set(Object data) {\n        this.data = data;\n    }\n}</code></pre>\n\n<p>Now suppose <code class=\"language-java\">Data</code> is parameterized by <code class=\"language-java\">&lt;T extends Number&gt;</code>. In this case, transformed code looks similar to the last code snippet with one difference: <code class=\"language-java\">Object</code> will be replaced by <code class=\"language-java\">Number</code>.</p>\n\n<p>If a value is assigned, a generic replacement can affect the accuracy of the program. If it is necessary to preserve type safety, the compiler inserts type casting. Let's look at the code:</p>\n\n<pre><code class=\"language-java\">Data&lt;String&gt; data = new Data(\"stored value\");\nString stored = data.get();</code></pre>\n\n<p>After type erasure is performed the code above is equivalent to:</p>\n\n<pre><code class=\"language-java\">Data data = new Data(\"stored value\");\nString stored = (String) data.get();</code></pre>\n\n<h2>Bridge methods</h2>\n\n<p>Sometimes to add type casting for preserving polymorphism the compiler has to generate synthetic methods. Let's now consider the extension of an already familiar <code class=\"language-java\">Data</code> class:</p>\n\n<pre><code class=\"language-java\">public class NumberData extends Data&lt;Number&gt; {\n    public void set(Number number) {\n        System.out.println(\"NumberData set\");\n        super.set(number);\n    }\n}</code></pre>\n\n<p>After<strong> </strong>type erasure <code class=\"language-java\"><tt>NumberData</tt></code> method becomes <code class=\"language-java\"><tt>set(Number number)</tt></code>, while the original <code class=\"language-java\"><tt>Data</tt></code> method is <code class=\"language-java\"><tt>set(Object obj)</tt></code>. As <code class=\"language-java\">NumberData</code> extends <code class=\"language-java\">Data</code>, it is possible to invoke <code class=\"language-java\">set(Object obj)</code> from <code class=\"language-java\">NumberData</code> instance and set objects of arbitrary type. To solve this problem and preserve the polymorphism of generic types after type erasure, Java compiler generates a so-called <strong>bridge method</strong> in the <code class=\"language-java\">NumberData</code> class. It overrides parameterized parent methods and provides type casting to specific parameters</p>\n\n<pre><code class=\"language-java\">public class NumberData extends Data {\n    // Bridge method generated by the compiler\n    public void set(Object object) {\n        super.set((Number) object);\n    }\n\n    public void set(Number number) {\n        super.set(number);\n    }\n\n    ...\n}</code></pre>\n\n<p>A bridge method is a synthetic method created by the compiler as a part of the type erasure process. It is presented in byte code only and not available for direct usage from java code. Normally you don't face bridge methods explicitly, although sometimes they might appear in a stack trace.</p>\n\n<h2>Conclusion</h2>\n\n<p>Type erasure is an operation that JVM runs during the compilation of source java code to byte code. It replaces the information about parameterization types by their upper bounds. It also inserts type casting and generates bridge methods. Type erasure transformation greatly influences the design of Java classes.</p>",
        "video": null,
        "options": {
          "language": ""
        }
      },
      "bloom_level": 0,
      "can_abandon": false,
      "can_skip": false,
      "check_profile": "",
      "comments_statistics": [
        {
          "thread": "comment",
          "total_count": 5
        },
        {
          "thread": "hint",
          "total_count": 0
        },
        {
          "thread": "useful link",
          "total_count": 0
        },
        {
          "thread": "solutions",
          "total_count": 0
        }
      ],
      "content_created_at": "2020-06-17T18:57:17Z",
      "id": 10086,
      "is_abandoned": false,
      "is_completed": false,
      "is_cribbed": false,
      "is_recommended": true,
      "is_next": false,
      "is_skipped": false,
      "last_completed_at": null,
      "likes_statistics": [
        {
          "subject": "",
          "value": -2,
          "total_count": 2
        },
        {
          "subject": "",
          "value": -1,
          "total_count": 2
        },
        {
          "subject": "",
          "value": 0,
          "total_count": 2
        },
        {
          "subject": "",
          "value": 1,
          "total_count": 6
        },
        {
          "subject": "",
          "value": 2,
          "total_count": 35
        },
        {
          "subject": "cheatsheet",
          "value": -1,
          "total_count": 4
        },
        {
          "subject": "cheatsheet",
          "value": 1,
          "total_count": 1
        }
      ],
      "lesson_stepik_id": 368651,
      "position": 1,
      "seconds_to_complete": 540.7724949998665,
      "solved_by": 575,
      "stage": null,
      "stepik_id": 1379861,
      "success_rate": null,
      "title": "Type Erasure",
      "topic": 84,
      "topic_theory": 10086,
      "type": "theory",
      "updated_at": "2020-12-20T16:42:27.241799Z",
      "content_updated_at": "2020-12-20T16:42:01Z",
      "progress_updated_at": "2021-01-23T14:29:57.439046Z",
      "popular_ide": null,
      "project": null,
      "is_beta": true,
      "is_deprecated": false,
      "error_issues_count": 0,
      "warning_issues_count": 0
    }
  ]
}