{
  "meta":{
    "page":1,
    "has_next":false,
    "has_previous":false
  },
  "steps":[
    {
      "block":{
        "name":"text",
        "text":"<p>Earlier, when we were discussing type bounds, we’ve mentioned <em>Wildcards</em> as a feature that does the same trick and has wide application.<br>\nWildcards are a specific Java tool that allows the implementation of some compatibility between different generic objects. The wildcard is basically “?” sign used to indicate that a class, a method, or a field is compatible with different type parameters.</p>\n\n<h2>Why Wildcards?</h2>\n\n<p>Since Java is an object-oriented language, the concept of inheritance is essential. However, since generics are type-safe structures it is impossible to introduce inheritance for Generic objects.<br>\nTo illustrate the problem, let’s consider two classes:</p>\n\n<pre><code class=\"language-java\">class Book{}\nclass Album extends Book {}</code></pre>\n\n<p>Logically we assume that a list of albums can be treated as a list of books, because <code class=\"language-java\">Album</code> is a subclass of <code class=\"language-java\">Book</code>. However, the compiler thinks in a different way:</p>\n\n<pre><code class=\"language-java\">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();\nList&lt;Book&gt; books = albums; // compile-time error</code></pre>\n\n<p>The root cause of the problem lies In the fact that <code class=\"language-java\">List&lt;Album&gt;</code> is not a subclass of <code class=\"language-java\">List&lt;Book&gt;</code>: a usual inheritance rule of Java does not work this way with generic classes. Such behavior is known as <strong>invariance</strong>. It doesn't matter that <code class=\"language-java\">Album</code> extends <code class=\"language-java\">Book</code>, their containers like a <code class=\"language-java\">List&lt;T&gt;</code>, <code class=\"language-java\">Set&lt;T&gt;</code> and others are treated like independent classes. It is extremely important to mind this fact every time you use generic classes.</p>\n\n<p>The example above is exactly where wildcards could help. A generic class or a method declared with wildcards can take any type parameter and there won't be any collisions with inheritance. To implement wildcards, use “?” inside angle brackets (<code class=\"language-java\">&lt;?&gt;</code>). Let's use it to make the compiler error go away in the example above:</p>\n\n<pre><code class=\"language-java\">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();\nList&lt;? extends Book&gt; albumsAndBooks = albums; // it is ok</code></pre>\n\n<p>or</p>\n\n<pre><code class=\"language-java\">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();\nList&lt;? super Album&gt; albumsAndBooks = albums; // it is ok as well</code></pre>\n\n<p>Wildcards are commonly used with some limitations that we called type bounds before: there we used only an <code class=\"language-java\">extends</code> keyword. Now we will take a look at another keyword <code class=\"language-java\">super</code>. Since wildcards are used for type bounding, they can be divided into three groups: unbounded wildcards, upper bounded wildcards, and lower bounded ones.</p>\n\n<h2>Upper Bounded Wildcards</h2>\n\n<p>Upper Bounded Wildcards are used when we want to set an upper bound. It is done with the <code class=\"language-java\">extends</code> keyword, like this:</p>\n\n<pre><code class=\"language-java\">? extends ReferenceType</code></pre>\n\n<p>It can be read as “any type that is a subtype of <code class=\"language-java\">ReferenceType</code>”. In other words, if <code class=\"language-java\">S</code> is a subtype of <code class=\"language-java\">T</code> then type <code class=\"language-java\">List&lt;S&gt;</code> is considered to be a subtype of <code class=\"language-java\">List&lt;? extends T&gt;</code>. That feature is known as <strong>covariance</strong>.</p>\n\n<p>Now imagine again that we are dealing with a library, where we have books of different types (normal books, booklets, albums and so on). We also may have some other media files like audio recordings. Let's introduce two classes:</p>\n\n<pre><code class=\"language-java\">public class Booklet extends Book {}\npublic class AudioFile {}</code></pre>\n\n<p>Now say we want to create storage for all types of books:</p>\n\n<pre><code class=\"language-java\">List&lt;? extends Book&gt; storage = new ArrayList&lt;&gt;();\n\nList&lt;Album&gt; albums = new ArrayList&lt;&gt;();\nstorage = albums; // it works, Album is a subtype of Book\n\nList&lt;Booklet&gt; booklets = new ArrayList&lt;&gt;();\nstorage = booklets; // it works, Booklet is a subtype of Book\n\nList&lt;AudioFile&gt; recordings = new ArrayList&lt;&gt;();\nstorage = recordings; // compile-time error, AudioFile is not a subtype of Book</code></pre>\n\n<p>This way we made sure that only subtypes of the <code class=\"language-java\">Book</code> can be put to the storage.</p>\n\n<p>Now let’s consider another limitation of upper bounding.</p>\n\n<pre><code class=\"language-java\">/**\n* Hierarchy: Book -&gt; Album\n*                 -&gt; Booklet\n* Allowed types: List&lt;Book&gt;, List&lt;Album&gt;, List&lt;Booklet&gt;\n*/\npublic void upperBoundedMethod(List&lt;? extends Book&gt; books) {\n    Book book = books.get(0); // It is fine\n\n    books.add(new Album()); // compile-time error\n    books.add(new Book());  // compile-time error\n    books.add(null); // also fine, because of null is a special type-independent value\n}</code></pre>\n\n<p>It may be surprising, but some lines of <code class=\"language-java\">upperBoundedMethod</code> won't compile. Upper bounded wildcards are completely fine with reading content as <code class=\"language-java\">Book</code> type, but writing is prohibited except a <code class=\"language-java\">null</code> value.</p>\n\n<p>Let's explain the logic. The compiler doesn't know which type of argument will be passed to the method in runtime. As we already learned, the method accepts list parameterized by <code class=\"language-java\">Book</code> or any of its subtypes: <code class=\"language-java\">List&lt;Books&gt;</code>, <code class=\"language-java\">List&lt;Album&gt;</code> or <code class=\"language-java\">List&lt;Booklet&gt;</code>. This is a reason why any object from <code class=\"language-java\">books</code> argument can be read as <code class=\"language-java\">Book</code>. However, writing is prohibited to avoid future runtime errors. Imagine the case when <code class=\"language-java\">List&lt;Album&gt;</code> was passed, but then we try to add an instance of <code class=\"language-java\">Book</code>. It can potentially lead to a runtime error because an added object will be treated as <code class=\"language-java\">Album</code> in the future.</p>\n\n<h2>Lower Bounded Wildcards</h2>\n\n<p>Lower Bounded Wildcards are introduced with the <code class=\"language-java\">super</code> keyword followed by the lower bound:</p>\n\n<pre><code class=\"language-java\">? super ReferenceType\n</code></pre>\n\n<p>It means \"any type that is a supertype of <code class=\"language-java\">ReferenceType</code>\" and that if <code class=\"language-java\">S</code> is a supertype of <code class=\"language-java\">T</code> then <code class=\"language-java\">List&lt;S&gt;</code> is considered to be a supertype of <code class=\"language-java\">List&lt;? super T&gt;</code>. The feature is called <strong>contravariance</strong>.</p>\n\n<p>Let’s think of books again. Now we would like to write a code that will enable <code class=\"language-java\">List</code> of <code class=\"language-java\">Albums</code> and its superclasses to be added to a general library.</p>\n\n<p>Take a look at the following code:</p>\n\n<pre><code class=\"language-java\">List&lt;? super Album&gt; storage = new ArrayList&lt;&gt;();\n\nList&lt;Album&gt; albums = new ArrayList&lt;&gt;();\nstorage = albums; // it works\n\nList&lt;Book&gt; books = new ArrayList&lt;&gt;();\nstorage = books; // it works, Book is a supertype for Album\n\nList&lt;Booklet&gt; booklets = new ArrayList&lt;&gt;();\nstorage = booklets; // compile-time error, Booklet is not a supertype for Album</code></pre>\n\n<p>Here we made sure that only supertypes of the <code class=\"language-java\">Album</code> class can be put to the storage.</p>\n\n<p>Now let’s consider another limitation of lower bounding.</p>\n\n<pre><code class=\"language-java\">/**\n* Hierarchy: Album &lt;- Book &lt;- Object  \n* Allowed types: List&lt;Album&gt;, List&lt;Book&gt;, List&lt;Object&gt;\n*/\npublic void lowerBoundedMethod(List&lt;? super Album&gt; albums) {\n    Object object = albums.get(0); // it is ok. Object is upper bound of Album\n    Book book = albums.get(0);     // compile-time error\n    Album album = albums.get(0);   // compile-time error\n\n    albums.add(new Object()); // compile-time error\n    albums.add(new Book());   // compile-time error\n    albums.add(new Album());  // OK\n    albums.add(null);         // OK, null is type-independent\n}</code></pre>\n\n<p>There are also some compile-time errors as well as for upper bounded wildcards. Let's explain why the compiler suspects these lines as potential danger.</p>\n\n<p>Since any of <code class=\"language-java\">List&lt;Album&gt;</code>, <code class=\"language-java\">List&lt;Book&gt;</code>, <code class=\"language-java\">List&lt;Object&gt;</code> can be passed to the <code class=\"language-java\">lowerBoundedMethod</code>, we can't assert that read object has a certain type <code class=\"language-java\">Album</code> or <code class=\"language-java\">Book</code>. We can only assume its type as <code class=\"language-java\">Object</code> for sure. </p>\n\n<p>On the other hand, only an instance of <code class=\"language-java\">Album</code> can be treated as <code class=\"language-java\">Book</code> and <code class=\"language-java\">Object</code> simultaneously, that is why we are allowed to add only <code class=\"language-java\">Album</code>. Otherwise, if we pass <code class=\"language-java\">List&lt;Album&gt;</code> to the method and add an instance of <code class=\"language-java\">Book</code>, it will lead to the instance of <code class=\"language-java\">Book</code> being treated as <code class=\"language-java\">Album</code> in the future. Such errors are prevented by the compiler.</p>\n\n<h2>Get and Put Principle</h2>\n\n<p>To detect and memorize whether <code class=\"language-java\">extends</code> or <code class=\"language-java\">super</code> should be used it is worth remembering the <em>Get and Put principle</em>:</p>\n\n<p>Use Upper Bounded Wildcards (i.e., <strong>&lt;? extends Number&gt;</strong>) when you only get values out of a structure (when you use only getters or similar methods), use Lower Bounded Wildcards (i.e., <strong>&lt;? super Integer&gt;</strong>) when you only put values into a structure (when you use only setters or similar methods) and do use Unbounded Wildcards (simple <strong>&lt;?&gt;</strong>) when you both get and put (when it is essential for you to use all kind of methods).</p>\n\n<p>To memorize this principle, you can also use PECS: Producer Extends, Consumer Super. This means that if you get a value from a generic class, method or any other object (it can <em>produce</em> for you what you need), you use <code class=\"language-java\">extends</code>. And vice versa, if you put or set a value into a generic class, method or any other object (it can <em>consume</em> what you put in it), you use <code class=\"language-java\">super</code>.</p>\n\n<p>Remember, that it is not possible to put anything into a type declared with an <code class=\"language-java\">extends</code> wildcard except for the <code class=\"language-java\">null</code> value since it can represent any reference type. Similarly, it is not possible to get anything from a type declared with <code class=\"language-java\">super</code> wildcard except for a value of an <code class=\"language-java\">Object</code> type: a super type for every reference type.</p>\n\n<p><div class=\"alert alert-warning\"> You cannot use a lower and an upper bound simultaneously in wildcards in particular and in type bounds in Java in general. </div> <strong>Note,</strong> that a class or an interface that is used after an “extends” or a “super” keyword itself is included in the inheritance. For example, <code class=\"language-java\">Box&lt;T&gt;</code> is absolutely compatible and covariant with <code class=\"language-java\">Box&lt;? extends T&gt;</code> or <code class=\"language-java\">Box&lt;? super T&gt;</code>.</p>\n\n<p>In the end, it is important to note that a frequently used unbounded wildcard  <code class=\"language-java\">?</code> is equivalent to: <code class=\"language-java\">? extends Object</code>.</p>\n\n<p><div class=\"alert alert-primary\"> It is interesting that an inheritance prohibition in generics is made specifically to prevent run-time errors: otherwise, generics would lose their type safety feature. </div></p>\n\n<h2>Wildcard Capture</h2>\n\n<p>Let's consider the example:</p>\n\n<pre><code class=\"language-java\">public static void reverse(List&lt;?&gt; list) {\n  List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list);\n  for (int i = 0; i &lt; list.size(); i++) {\n    list.set(i, tmp.get(list.size() - i - 1)); // compile-time error\n  }\n}</code></pre>\n\n<p>On the first look, this example may seem ok to you, but compile-error hints us it is not. As you know <code class=\"language-java\">&lt;?&gt;</code> equivalent to <code class=\"language-java\">&lt;? extends Object&gt;</code>, so by PECS principle, we cannot mutate the content of <code class=\"language-java\">list</code>, just read it. The scenario is known as <strong>wildcard capture</strong> problem and can be solved by the trick:</p>\n\n<pre><code class=\"language-java\">public static void reverse(List&lt;?&gt; list) { \n  reverseCaptured(list); \n}\n\nprivate static &lt;T&gt; void reverseCaptured(List&lt;T&gt; list) {\n  List&lt;T&gt; tmp = new ArrayList&lt;T&gt;(list);\n  for (int i = 0; i &lt; list.size(); i++) {\n    list.set(i, tmp.get(list.size() - i - 1));\n  }\n}</code></pre>\n\n<p>Here we introduced a helper method <code class=\"language-java\">reverseCaptured</code> which has a parameter of a certain type <code class=\"language-java\">T</code> for all elements of list. The method is completely fine from the compiler point of view because it is a merely <strong>generic method</strong>.</p>\n\n<h2>Conclusion</h2>\n\n<p>Wildcards are a very convenient and safe way of implementing an equivalent of inheritance in Generics. They are declared as a “?” in angle brackets and are widely used with upper or lower bounds to restrict type parameters.<br>\nWildcards are mainly used inside different libraries and frameworks, as well as generics themselves.</p>",
        "video":null,
        "options":{
          "language":""
        }
      },
      "bloom_level":0,
      "can_abandon":false,
      "can_skip":false,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":11
        },
        {
          "thread":"hint",
          "total_count":0
        },
        {
          "thread":"useful link",
          "total_count":1
        },
        {
          "thread":"solutions",
          "total_count":0
        }
      ],
      "content_created_at":"2020-04-19T18:14:24Z",
      "id":9455,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":true,
      "is_skipped":false,
      "last_completed_at":null,
      "likes_statistics":[
        {
          "subject":"",
          "value":2,
          "total_count":70
        },
        {
          "subject":"",
          "value":1,
          "total_count":5
        },
        {
          "subject":"cheatsheet",
          "value":1,
          "total_count":2
        },
        {
          "subject":"",
          "value":0,
          "total_count":4
        },
        {
          "subject":"cheatsheet",
          "value":0,
          "total_count":1
        },
        {
          "subject":"cheatsheet",
          "value":-1,
          "total_count":2
        },
        {
          "subject":"",
          "value":-2,
          "total_count":2
        }
      ],
      "lesson_stepik_id":343945,
      "position":1,
      "seconds_to_complete":1727.8475800000392,
      "solved_by":860,
      "stage":null,
      "stepik_id":1249400,
      "success_rate":null,
      "title":"Wildcards",
      "topic":85,
      "topic_theory":9455,
      "type":"theory",
      "updated_at":"2020-10-25T15:21:25.451885Z",
      "content_updated_at":"2020-10-25T15:21:11Z",
      "progress_updated_at":"2021-02-09T02:22:49.817310Z",
      "popular_ide":"IdeaEdu",
      "project":null,
      "is_beta":false,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":21
    },
    {
      "block":{
        "name":"code",
        "text":"<p>You are working in a Pie company. The business going well and bakeries are selling abroad. Sometimes due to custom rules and trade regulations, it is necessary to package bakeries into the box with a more basic name like Bakery or Food. Full class hierarchy follows:</p>\n\n<pre><code class=\"language-java\">class Food {}\n\nclass Bakery extends Food {}\n\nclass Cake extends Bakery {}\n\nclass Pie extends Bakery {}\n\nclass Tart extends Bakery {}\n\ninterface Box&lt;T&gt; {\n    public void put(T item);\n    public T get();\n}</code></pre>\n\n<p>There is <code class=\"language-java\">Packer</code> class available, but it is designed with business rule violation and lacks implementation. Correct the Packer code to ensure that:</p>\n\n<ul>\n\t<li>Any kind of Bakery could be repacked to the Box with a more basic type (e.g. from box with Pie to box with Food)</li>\n\t<li>Basic stuff like food can't be repacked into narrowly typed Boxes (e.g. with Cakes)</li>\n\t<li>Arbitrary stuff like Strings or Objects can't be repacked without compile-time errors or warnings</li>\n\t<li>Repacking actually happens</li>\n</ul>\n\n<p>If you cannot solve this task too much time, try to skip it.</p>",
        "video":null,
        "options":{
          "execution_time_limit":5,
          "execution_memory_limit":256,
          "limits":{
            "java11":{
              "time":8,
              "memory":256
            }
          },
          "code_templates":{
            "java11":"/**\n    This packer has too much freedom and could repackage stuff in wrong direction.\n    Fix method types in signature and add implementation. \n*/\nclass Packer {\n\n\tpublic void repackage(Box to, Box from) {\n\t\t// Implement repackaging\n\t}\n\n}\n\n// Don't change classes below\nclass Box<T> {\n\n    private T item;\n\n    public void put(T item) {\n    \tthis.item = item;\n    }\n\n    public T get() {\n        return this.item;\n    }\n\n}\n\nclass Goods {}\n\nclass Food extends Goods {}\n\nclass Bakery extends Food {}\n\nclass Cake extends Bakery {}\n\nclass Pie extends Bakery {}\n\nclass Tart extends Bakery {}"
          },
          "code_templates_header_lines_count":{
            "java11":12
          },
          "code_templates_footer_lines_count":{
            "java11":101
          },
          "code_templates_options":{

          },
          "samples":[

          ],
          "is_run_user_code_allowed":true,
          "language":""
        }
      },
      "bloom_level":2,
      "can_abandon":true,
      "can_skip":true,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":30
        },
        {
          "thread":"hint",
          "total_count":11
        },
        {
          "thread":"useful link",
          "total_count":1
        },
        {
          "thread":"solutions",
          "total_count":17
        }
      ],
      "content_created_at":"2017-10-18T16:38:42Z",
      "id":2640,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":false,
      "is_skipped":false,
      "last_completed_at":"2021-02-08T14:29:42.791032Z",
      "likes_statistics":[
        {
          "subject":"",
          "value":0,
          "total_count":8
        },
        {
          "subject":"",
          "value":-2,
          "total_count":16
        },
        {
          "subject":"",
          "value":1,
          "total_count":4
        },
        {
          "subject":"",
          "value":-1,
          "total_count":5
        },
        {
          "subject":"skip",
          "value":102,
          "total_count":32
        },
        {
          "subject":"skip",
          "value":100,
          "total_count":98
        },
        {
          "subject":"",
          "value":2,
          "total_count":46
        },
        {
          "subject":"skip",
          "value":0,
          "total_count":1
        }
      ],
      "lesson_stepik_id":59009,
      "position":1,
      "seconds_to_complete":803.1358150000144,
      "solved_by":678,
      "stage":null,
      "stepik_id":232865,
      "success_rate":0.362,
      "title":"Packing bakeries",
      "topic":85,
      "topic_theory":9455,
      "type":"practice",
      "updated_at":"2021-02-01T16:39:32.748810Z",
      "content_updated_at":"2021-02-01T16:39:15Z",
      "progress_updated_at":"2021-02-04T22:36:43.778249Z",
      "popular_ide":"idea",
      "project":null,
      "is_beta":true,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":0
    },
    {
      "block":{
        "name":"choice",
        "text":"Type&lt;?&gt; wildcard is equivalent to:",
        "video":null,
        "options":{
          "is_multiple_choice":false,
          "language":""
        }
      },
      "bloom_level":1,
      "can_abandon":false,
      "can_skip":true,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":0
        },
        {
          "thread":"hint",
          "total_count":0
        },
        {
          "thread":"useful link",
          "total_count":0
        },
        {
          "thread":"solutions",
          "total_count":0
        }
      ],
      "content_created_at":"2017-10-15T13:25:11Z",
      "id":2645,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":false,
      "is_skipped":false,
      "last_completed_at":"2021-02-08T13:56:36.790467Z",
      "likes_statistics":[
        {
          "subject":"",
          "value":2,
          "total_count":23
        },
        {
          "subject":"",
          "value":1,
          "total_count":4
        }
      ],
      "lesson_stepik_id":58762,
      "position":1,
      "seconds_to_complete":13.19674499999755,
      "solved_by":319,
      "stage":null,
      "stepik_id":231787,
      "success_rate":0.8655913978494624,
      "title":"Find an equivalent",
      "topic":85,
      "topic_theory":9455,
      "type":"practice",
      "updated_at":"2020-07-16T08:20:21.649758Z",
      "content_updated_at":"2018-08-17T16:03:53Z",
      "progress_updated_at":"2021-02-09T02:22:49.817310Z",
      "popular_ide":null,
      "project":null,
      "is_beta":false,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":0
    },
    {
      "block":{
        "name":"choice",
        "text":"<p>What will be the result of the following code compilation and execution:</p><pre><code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\npublic class Application {\n  \n  public static void main(String[] args) {\n    System.out.println(wildcardsTest(new ArrayList&lt;&gt;()));  \n  }\n  \n  public static Object wildcardsTest(List&lt;? super Object&gt; numbers) {\n    numbers.add(10);\n    return numbers.get(0);\n  }\n\n}</code></pre>",
        "video":null,
        "options":{
          "is_multiple_choice":false,
          "language":""
        }
      },
      "bloom_level":1,
      "can_abandon":false,
      "can_skip":true,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":1
        },
        {
          "thread":"hint",
          "total_count":0
        },
        {
          "thread":"useful link",
          "total_count":0
        },
        {
          "thread":"solutions",
          "total_count":0
        }
      ],
      "content_created_at":"2017-10-18T16:22:39Z",
      "id":2638,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":false,
      "is_skipped":false,
      "last_completed_at":"2021-02-08T14:01:43.089309Z",
      "likes_statistics":[
        {
          "subject":"",
          "value":1,
          "total_count":4
        },
        {
          "subject":"",
          "value":0,
          "total_count":3
        },
        {
          "subject":"",
          "value":2,
          "total_count":25
        },
        {
          "subject":"skip",
          "value":102,
          "total_count":1
        },
        {
          "subject":"",
          "value":-2,
          "total_count":1
        }
      ],
      "lesson_stepik_id":58944,
      "position":1,
      "seconds_to_complete":68.81878000000084,
      "solved_by":435,
      "stage":null,
      "stepik_id":232851,
      "success_rate":0.42,
      "title":"The result of the code",
      "topic":85,
      "topic_theory":9455,
      "type":"practice",
      "updated_at":"2020-08-21T21:17:46.102739Z",
      "content_updated_at":"2019-08-19T08:39:42Z",
      "progress_updated_at":"2021-02-09T02:22:49.817310Z",
      "popular_ide":null,
      "project":null,
      "is_beta":false,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":0
    },
    {
      "block":{
        "name":"string",
        "text":"<p>You are invited to Pie company that succeeds in baking and packing Pies. Their current infrastructure is described in code:</p>\n\n<pre><code class=\"language-java\">// Different Bakeries that should be packed to Box'es and delivered to customers\nclass Bakery {}\n\nclass Cake extends Bakery {}\n\nclass Pie extends Bakery {}\n\nclass Tart extends Bakery {}\n\n// This (of course) can be packed in box, but we want to disable it's delivery to customers\nclass Paper {}\n\n// Implementing class exists that is used to pack everything\ninterface Box&lt;T&gt; {\n    public void put(T item);\n    public T get();\n}</code></pre>\n\n<p>\nNow they decided to deliver bakeries to the customers and ask you to design Deliveryman class. The deliverymen should succeed in following:\n</p>\n\n<ul>\n\t<li>Deliver Bakery or any subclass of it, packed into boxes</li>\n\t<li>Do not deliver anything else (e.g. Paper)</li>\n\t<li>Prohibit Deliveryman to <em>put</em> anything into the Box inside <em>deliver</em> method at a compile time by raising errors or warnings.</li>\n</ul>\n\n<p>Your task is to create method signature leaving implementation unchanged. The Deliveryman template follows:</p>\n\n<pre><code class=\"language-java\">public class Deliveryman {\n   // Method to change signature of\n   public void deliver(Box box) {\n     // He knows how to do this, leave unchanged\n   }\n   \n}</code></pre>\n\n<p>So, instead of  <code class=\"language-java\">public void deliver(Box box)</code> write the line that replaces it in the field below.</p>",
        "video":null,
        "options":{
          "language":""
        }
      },
      "bloom_level":2,
      "can_abandon":true,
      "can_skip":true,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":0
        },
        {
          "thread":"hint",
          "total_count":5
        },
        {
          "thread":"useful link",
          "total_count":0
        },
        {
          "thread":"solutions",
          "total_count":2
        }
      ],
      "content_created_at":"2018-10-29T12:32:24Z",
      "id":4893,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":false,
      "is_skipped":false,
      "last_completed_at":"2021-02-08T17:40:37.560173Z",
      "likes_statistics":[
        {
          "subject":"skip",
          "value":102,
          "total_count":6
        },
        {
          "subject":"skip",
          "value":100,
          "total_count":18
        },
        {
          "subject":"",
          "value":2,
          "total_count":45
        },
        {
          "subject":"",
          "value":1,
          "total_count":7
        },
        {
          "subject":"",
          "value":-2,
          "total_count":4
        },
        {
          "subject":"",
          "value":0,
          "total_count":2
        },
        {
          "subject":"",
          "value":-1,
          "total_count":1
        }
      ],
      "lesson_stepik_id":186614,
      "position":1,
      "seconds_to_complete":214.8363750000135,
      "solved_by":552,
      "stage":null,
      "stepik_id":525047,
      "success_rate":0.389,
      "title":"Fix signature",
      "topic":85,
      "topic_theory":9455,
      "type":"practice",
      "updated_at":"2020-09-30T19:12:38.198902Z",
      "content_updated_at":"2020-03-24T12:07:41Z",
      "progress_updated_at":"2021-02-09T02:22:49.817310Z",
      "popular_ide":null,
      "project":null,
      "is_beta":false,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":0
    },
    {
      "block":{
        "name":"code",
        "text":"<p>You are provided with the backbone of <code class=\"language-java\">ListMultiplicator</code> class that has a method that takes a list and repeats its content a specified number of times. The method should change the original list content.</p>\n\n<p>Your task is to add implementation to the method without changing its signature.</p>\n\n<p>It is guaranteed that:</p>\n\n<ul>\n\t<li>the list is not null</li>\n\t<li><em>n</em> equals or is greater than zero</li>\n</ul>\n\n<p><em>n</em> stands for the number of times the original list is repeated in the result. In case <em>n </em>equals zero, the resulting list should be empty.</p>\n\n<p>For example, if <em>n </em>equals 2 and the original list is:</p>\n\n<pre><code class=\"language-java\">[1, 2, 3] </code></pre>\n\n<p>the result should be:</p>\n\n<pre><code class=\"language-java\">[1, 2, 3, 1, 2, 3]</code></pre>",
        "video":null,
        "options":{
          "execution_time_limit":5,
          "execution_memory_limit":256,
          "limits":{
            "java11":{
              "time":8,
              "memory":256
            }
          },
          "code_templates":{
            "java11":"import java.util.List;\n\n/**\n    Class to modify\n*/\nclass ListMultiplicator {\n\n    /**\n        Repeats original list content provided number of times   \n        @param list list to repeat\n        @param n times to repeat, should be zero or greater\n    */\n\tpublic static void multiply(List<?> list, int n) {\n\t\t// Add implementation here\n\t}\n}"
          },
          "code_templates_header_lines_count":{
            "java11":9
          },
          "code_templates_footer_lines_count":{
            "java11":106
          },
          "code_templates_options":{

          },
          "samples":[

          ],
          "is_run_user_code_allowed":true,
          "language":""
        }
      },
      "bloom_level":2,
      "can_abandon":true,
      "can_skip":true,
      "check_profile":"",
      "comments_statistics":[
        {
          "thread":"comment",
          "total_count":26
        },
        {
          "thread":"hint",
          "total_count":18
        },
        {
          "thread":"useful link",
          "total_count":2
        },
        {
          "thread":"solutions",
          "total_count":55
        }
      ],
      "content_created_at":"2017-10-18T16:40:27Z",
      "id":2641,
      "is_abandoned":false,
      "is_completed":false,
      "is_cribbed":false,
      "is_recommended":true,
      "is_next":false,
      "is_skipped":false,
      "last_completed_at":"2021-02-08T13:55:50.969437Z",
      "likes_statistics":[
        {
          "subject":"",
          "value":-2,
          "total_count":22
        },
        {
          "subject":"",
          "value":2,
          "total_count":49
        },
        {
          "subject":"",
          "value":1,
          "total_count":11
        },
        {
          "subject":"skip",
          "value":100,
          "total_count":105
        },
        {
          "subject":"skip",
          "value":102,
          "total_count":32
        },
        {
          "subject":"",
          "value":0,
          "total_count":5
        },
        {
          "subject":"",
          "value":-1,
          "total_count":6
        },
        {
          "subject":"skip",
          "value":0,
          "total_count":4
        },
        {
          "subject":"skip",
          "value":101,
          "total_count":3
        }
      ],
      "lesson_stepik_id":59010,
      "position":1,
      "seconds_to_complete":930.7739999999999,
      "solved_by":744,
      "stage":null,
      "stepik_id":232866,
      "success_rate":0.205,
      "title":"List multiplicator",
      "topic":85,
      "topic_theory":9455,
      "type":"practice",
      "updated_at":"2021-02-01T16:37:12.247230Z",
      "content_updated_at":"2021-02-01T16:36:49Z",
      "progress_updated_at":"2021-02-09T02:22:49.817310Z",
      "popular_ide":"idea",
      "project":null,
      "is_beta":true,
      "is_deprecated":false,
      "error_issues_count":0,
      "warning_issues_count":0
    }
  ]
}